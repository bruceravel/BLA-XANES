* Convert bent-Laue analyzer images to XANES data

** Synopsis

A measurement set consists of

 + A column data file with columns of energy and scalars from the
   measurement.

 + One Pilatus image for each energy point in the XANES scan
   containing the HERFD signal at that point.

 + A set of Pilatus images taken at energies around the fluorescence
   energy.  These are used to make a mask which identifies which
   pixels contain signal related to specific emission energies.

This software uses perl, [[https://metacpan.org/module/Imager][Imager]], and [[http://pdl.perl.org][PDL]] to process the images into a
high resolution XANES spectrum.  Imager is used to import data from
the signed 32 bit numbers.  That data is immediately pushed into a PDL
object for all further processing.

** Installation

To install, do the following:

:      perl Build.PL
:      sudo ./Build installdeps  ## (if any dependencies are not met)
:      ./Build
:      ./Build test
:      sudo ./Build install


** Usage

There is a single program installed from the bin/ folder.  ~bla~ is a
wrapper script around the five bent Laue tasks:

 1. ~herfd~: make a single HERFD spectrum at a specific
    emission energy

 2. ~rixs~: generate a sequence of HERFD spectra at a
    sequence of emission energies

 3. ~map~: convert a series of elastic images to an
    energy vs. pixel map

 4. ~mask~: compute the mask file for a specific emission energy

 5. ~point~: convert a specified BLA image to its HERFD value for a
    specified emission energy

*** The bla script

:  bla herfd [cxeasvnqh] <stub>
:  bla rixs  [cxasvnqh]  <stub>
:  bla map   [crvnqh]    <stub>
:  bla mask  [casvnqh]   <stub>
:  bla point [ceph]      <stub>
: 
:     --config  | -c    [string]  configuration file (required)
:     --energy  | -e    [integer] emission energy (required for herfd/point tasks)
:     --point   | -p    [integer] data point at which compute HERFD (required for point task)
:     --xdiini  | -x    [string]  XDI configuration file
:     --reuse   | -r    [flag]    reuse mask files for energy map if in outfolder
:     --animate | -a    [flag]    save gif animation of mask creation
:     --save    | -s    [flag]    save gif with mask
:     --verbose | -v    [flag]    write progress messages
:     --nocolor | -n    [flag]    turn off color coding of screen output
:     --quiet   | -q    [flag]    suppress progress messages
:     --help    | -h    [flag]    write this message and exit

The ~bla~ script assumes that scan files and image files have
related names.  In this example, the scan file is called ~Aufoil1.001~
and the image files are called ~Aufoil1_NNNNN.tif~.  The ~NNNNN~ in
the image file name indicates the data point and is reflected in one
of the columns of the scan file.  If your data do not follow these
patterns, this script will fail.  File locations are specified in the
configuration file.

:  examples:  bla herfd -c=/path/to/config.ini -e=9713 -a Aufoil1
:             bla rixs -c=/path/to/config.ini -a Aufoil1
:             bla map -c=/path/to/config.ini Aufoil1
:             bla mask -c=/path/to/config.ini -e=9713 Aufoil1
:             bla point -c=/path/to/config.ini -e=9713 -p=10 Aufoil1


Here, "Aufoil1" is the stub, i.e. the basename of the scan and image
files, and the ~-c~, ~-e~, and ~-a~ command line options are
demonstrated.

Options that are not used by a function (for example ~-e~ for ~rixs~
or ~map~, ~-a~ for ~map~, or ~-p~ for any task other than ~point~)
will be silently ignored.

~-c~ is required for all functions unless the ~BLACONFIG~ environment
variable is set.

Since the ~point~ task returns a number intended for use during data
acquisition, verbosity is turned off regardless of the command line
switches.  Use the ~-q~ flag if you want to suppress screen messages
during the ~mask~ task.  Saving is turned on for the ~mask~ task
regardless of the command line switches.

*** Environment variables

Use of the ~-c~ flag can be avoided by setting the ~BLACONFIG~
environment variable.  The following are equivalent:

:   bla herfd -c=/path/to/config.ini -e=9713 -a Aufoil1
: 
:   export BLACONFIG=/path/to/config.ini
:   bla herfd -e=9713 -a Aufoil1

Use of the ~-e~ flag can be avoided by setting the ~BLAENERGY~
environment variable.  The following are equivalent:

:   bla herfd -c=/path/to/config.ini -e=9713 -a Aufoil1
: 
:   export BLAENERGY=9713
:   bla herfd -c=/path/to/config.ini -a Aufoil1

Both environment variables are overridden by their respective command
line switches.

*** Output

 + The output of the ~herfd~ task is a data file containing the
   HERFD spectrum at the specified emission energy and, if requested,
   gif images with the mask and the mask creation animation.

 + The output of the ~rixs~ task is the same as for the ~herfd~
   script at each emission energy.

 + The output of the ~map~ task is a data file in a [[http://gnuplot.info/docs_4.2/gnuplot.html#x1-33600045.1.2][simple format]]
   which can be read by gnuplot and a gnuplot script for displaying
   the data.  The resulting image will plot a map of detector column
   vs detector row with the color axis showing energy.  Gif files for
   the masks at each emission energy are also written.

 + The output of the ~mask~ task is a single gif file containing the
   mask for the specified emission energy.

 + The output of the ~point~ task is the HERFD value extracted from a
   specified BLA image for a specified emission energy.  The value is
   printed to STDOUT.  If files containing the BLA image or the
   emission mask do not exist or if any other problem is encountered,
   0 is printed to STDOUT.

The ~herfd~, ~rixs~, and ~map~ tasks are intended for post-processing
of a full data set.

The ~mask~ and ~point~ tasks are intended for inlining in the data
acquisition process.  The ~mask~ task should be run after measuring
the elastic images at the emission energy and before measuring the
HERFD data.  The ~mask~ task takes about 10 seconds.

The ~point~ task is intended for generating the HERFD value at a
specific emission energy during the scan.  This value can be used for
plotting or storing to the output data file.  The ~point~ task takes
lass than 1 second.

*** The configuration file

The configuration file is in the Windows-style ini format.  Here is an
example:

:   [measure]
:   emission   = 9703 9705 9707 9709 9711 9713 9715 9717 9719
:   scanfolder = /home/bruce/Data/NIST/10ID/2011.12/scans
:   tiffolder  = /home/bruce/Data/NIST/10ID/2011.12/tiffs
:   outfolder  = /home/bruce/Data/NIST/10ID/2011.12/processed
:   element    = Au
:   line       = La1
: 
:   [steps]
:   steps = <<END
:   bad 400 weak 0
:   multiply by 5
:   areal mean radius 2
:   bad 400 weak 2
:   lonely 3
:   social 2
:   END

[[https://github.com/bruceravel/BLA-XANES/blob/master/share/config.ini][Here is an example configuration file.]]  (It is important not to
cut-and-paste the example above in a way that preserves the org-mode
mark-up.)

The ~emission~ can use a more concise syntax if the sequence of
elastic energies was measured on a uniform grid.  The following are
equivalent:

:   emission   = 9703 9705 9707 9709 9711 9713 9715 9717 9719
:
:   emission   = 9703 to 9719 by 2

White space does not matter, but the words ~to~ and ~by~ are required.

This configuration file can sit anywhere on disk and *must* be
specified at the command line or via the ~BLACONFIG~ environment
variable when using the ~bla~ script.  I would recommend that you put
it in the current work directory wherever you are working on your
data.  You may wish to keep multiple configuration files around for
different experiments, different edges, different samples, etc.

In the ~[measure]~ section, the ~emission~ item, which is not used by
the ~herfd~ function, contains the list of emission energies at which
to generate HERFD spectra.  The next three items are the locations of
the scan files, the image files, and the output files.  The last two
items are used to properly scale the color palette of the energy map
by positively identifying the emission line measured.

The ~[steps]~ section is used to define the sequence of operations
used to make the mask at any emission energy.  The syntax of this
section is somewhat fussy.  It is essential that there are no spaces
after either instance of the word ~END~.  Other than that, white space
is not important, but spelling is.

The possible steps to mask creation are:

 1. Bad and weak pixel removal.  The syntax is ~bad # weak #~.  The
    first number indicates the value above which a pixel is assumed to
    be a bad pixel.  The second number is the value below which a
    pixel is considered weak.  Both bad and weak pixels are removed
    from the mask.

 2. Multiply emission image by an overall constant.  The syntax is
    ~multiply by #~ where the number is the constant scaling factor.

 3. Apply an areal median or mean to each pixel.  The syntax is 
    ~areal <median|mean> radius #~.  The number defines the size of
    the square considered around each pixel.  A value of 1 means a 3x3
    square, a value of 2 means a 5x5 square.  The value of each pixel
    is set to either the mean or the median value of the pixels in the
    square.

 4. Remove all the lonely pixels.  A lonely pixel is one which is
    illuminated but is not surrounded by enough illuminated pixels.
    The syntax is ~lonely #~.  The number defines how many illuminated
    pixels are required for a pixel not to be considered lonely.

 5. Include all social pixels.  A social pixel is one which is not
    illuminated but is surrounded by enough illuminated pixels.  The
    syntax is ~social #~.  The number defines how many of the
    surrounding pixels must be illuminated for the pixel to be turned
    on.

 6. Use the entire image.  The syntax is ~entire image~. This step
    just sets all the pixels in the mask to 1 so that the entire image
    is used to compute the energy point.  Note that it makes no sense
    to use this step with any step other than the bad/weak step, which
    should precede this step.

The steps can come in any order and can be repeated.  At the end of
the final step, the illuminated pixels in the mask will be set to a
value of 1 so that the final mask can be used as an AND mask to create
the HERFD spectra.

Care is taken at the end to remove bad pixels that might have been
restored by the areal or social pixel steps.


*** Error checking

The script is not particularly robust in terms of flagging problems.
You should not expect particularly useful error messages if the
folders in the configuration file are not correct or if you give an
emission energy value that was not measured as an elastic image.  In
those cases, the program will almost certainly fail with some kind of
stack trace, but probably not with an immediately useful error
message.

*** XDI Output

When a configuration file containing XDI metadata is used, the output
files will be written in XDI format.  This is particularly handy for
the RIXS function.  If XDI metadata is provided, then the
~BLA.pixel_ratio~ metadatum will be written to the output file.  This
number is computed from the number of pixels illuminated in the mask
at each emission energy.  The pixel ratio for an emission energy is
the number of pixels from the emission energy with the largest number
of illuminated pixels divided by the number of illuminated pixels at
that energy.

The pixel ratio can be used to normalize the mu(E) data from each
emission energy.  The concept is that the normalized mu(E) data are an
approximation of what they would be if each emission energy was
equally represented on the face of the detector.

The version of Athena based on Demeter will be able to use these
values as importance or plot multiplier values if the ~Xray::XDI~
module is available.

** Scan conversion

At each energy point, the HERFD signal is computed from the Pilatus
image using the mask created as described above.  The counts on each
pixel lying within the illuminated portion of the mask are summed.
This sum is the HERFD signal at that incident energy.

A column data file is written containing the energy and several
scalars from the original measurement and a column containing the
HERFD signal.  This file can be imported directly into Athena.

** Working with Imager

Imager works out of the box on both Linux and Windows, although the
way it handles 32-bit numbers with its inherent 24-bit sample depth is
somewhat confusing.

** Working with Image Magick

In principle [[http://www.imagemagick.org/script/index.php][Image Magick]] can be used instead of Imager, but doing so
is a bit of work.

I am using [[http://www.imagemagick.org/script/index.php][Image Magick]] and its [[http://www.imagemagick.org/script/perl-magick.php][Perl interface]] as one of the image
handling backends for this project.  As delivered, Image Magick cannot
handle the TIFF files as written by the [[http://www.dectris.com/sites/pilatus100k.html][Pilatus 100K]] imagine detector.
In order to be able to use Image Magick, it must be recompiled with a
larger bit depth.  This is done by re-compiling from source code.

You must have [[http://www.libtiff.org/][libtiff]] and its development libraries installed so that
Image Magick gets compiled with support for tiff files.  On Ubuntu,
it is called ~libtiff4-dev~.

Grab the trunk of the Image Magick development version

:       svn co https://www.imagemagick.org/subversion/ImageMagick/trunk ImageMagick

then

:      ./configure --with-quantum-depth=32

Presumably, the same could be done with any Image Magick source
tarball.

I also rebuilt the perl wrapper which comes with the Image Magick
source code in the ~PerlMagick~ folder.  This also was a bit tricky.
My Ubuntu system has perl 5.10.1 and therefore has a
~libperl.5.10.1.so~.  It did not, however, have a ~libperl.so~
symlinked to it.  To get the perl wrapper to build, I had to do

:      sudo ln -s /usr/lib/libperl.so.5.10.1 /usr/lib/libperl.so

Adjust the version number on the perl library as needed for your
computer.

I was unable to compile Image Magick for Windows using MinGW, even
armed with a fairly complete set of GnuWin32 libraries and even
attempting it with a stable version (as opposed to the development
trunk).  Oh well....
