
* Convert bent-laue analyzer images to XANES data

** Synopsis

A measurement set consists of

 + A column data file with columns of energy and scalars from the
   measurement.

 + One Pilatus image for each energy point containing the HERFD signal
   at that point.

 + A set of Pilatus images taken at energies around the fluorescence
   energy.  These are used to make a mask which identifies which
   pixels contain signal related to specific emission energies.

This software uses perl and [[https://metacpan.org/module/Imager][Imager]] or [[http://pdl.perl.org][PDL]] to process the images into a
high resolution XANES spectrum.  Imager is used to import data from
the signed 32 bit numbers.  That data is immediately pushed into a PDL
object for further processing.

** Installation

To install, do the following:

:      perl Build.PL
:      sudo ./Build installdeps  ## (if any dependencies are not met)
:      ./Build
:      ./Build test
:      sudo ./Build install


** Usage

There is a single programs installed from the bin/ folder.  ~bla~ is a
wrapper script around the three bent Laue functions:

 1. ~herfd~: make a single HERFD spectrum at a specific
    emission energy

 2. ~rixs~: generate a sequence of HERFD spectra at a
    sequence of emission energies

 3. ~map~: convert a series of elastic images to an
    energy vs. pixel map

*** The bla script

:  bla herfd [ceasvnqh] <stub>
:  bla rixs  [casvnqh]  <stub>
:  bla map   [crvnqh]   <stub>
:
:     --config  | -c    [string]  configuration file (required)
:     --energy  | -e    [integer] emission energy (required for HERFD)
:     --reuse   | -r    [flag]    reuse mask files for energy mnap if in outfolder
:     --animate | -a    [flag]    save tiff animation of mask creation
:     --save    | -s    [flag]    save tiff with mask
:     --verbose | -v    [flag]    write progress messages
:     --nocolor | -n    [flag]    turn off color coding of screen output
:     --quiet   | -q    [flag]    suppress progress messages
:     --help    | -h    [flag]    write this message and exit

  
The ~bla~ script assumes that scan files and image files have
related names.  In this example, the scan file is called ~Aufoil1.001~
and the image files are called ~Aufoil1_NNNNN.tif~.  The ~NNNNN~ in
the image file name indicates the data point and is reflected in one
of the columns of the scan file.  If your data do not follow these
patterns, this script will fail.  File locations are specified in the
configuration file.

:  examples:  bla herfd -c /path/to/config.ini -e 9713 -a Aufoil1
:             bla rixs -c /path/to/config.ini -a Aufoil1
:             bla map -c /path/to/config.ini Aufoil1


Here, "Aufoil1" is the stub, i.e. the basename of the scan and image
files, and the ~-c~, ~-e~, and ~-a~ command line options are
demonstrated.

Options that are not used by a function (for example ~-e~ for ~rixs~
or ~map~, or ~-a~ for ~map~) will be silently ignored.

~-c~ is required for all functions.

*** Output

 + The output of the ~herfd~ script is a data file containing the
   HERFD spectrum at the specified eminssion energy and, if requested,
   tiff images with the mask and the mask creation animation.

 + The output of the ~rixs~ script is the same as for the ~herfd~
   script at each emission energy.

 + The output of the ~map~ program is a datafile in a [[http://gnuplot.info/docs_4.2/gnuplot.html#x1-33600045.1.2][simple format]]
   which can be read by gnuplot and a gnuplot script for displaying
   the data.  The resulting image will plot a map of detector column
   vs detector row with the color axis showing energy.  Tiff files for
   the masks at each emission energy are also written.

*** The configuration file

The configuration file is in the Windows-style ini format.  Here is an
example.

:   [measure]
:   emission   = 9703 9705 9707 9709 9711 9713 9715 9717 9719
:   scanfolder = /home/bruce/Data/NIST/10ID/2011.12/scans
:   tiffolder  = /home/bruce/Data/NIST/10ID/2011.12/tiffs
:   outfolder  = /home/bruce/Data/NIST/10ID/2011.12/processed
:   element    = Au
:   line       = La1
:
:   [pixel]
:   maskmode = 2
:   bad    = 400
:   weak   = 2
:   lonely = 2
:   social = 2
:   radius = 2

The ~emission~ item, which is not used by the ~herfd~ function,
contains the list of emission energies at which to generate HERFD
spectra.  The other three items are the locations of the scan files,
the image files, and the output files.

This configuration file can sit anywhere on disk and *must* be
specified at the command line for either script.  I would recommend
that you put it in the current work directory wherever you are working
on your data.  You may wish to keep multiple configuration files
around for different experiments, different edges, etc.

The four items in the ~[pixel]~ section are used in mask creation, as
explained below under "Mask". ~maskmode~ is used to set the mask
creation algorithm.  1 means to use the lonely/social algorithm, 2
means to use the areal median/mean algorithm, 3 means to use the whole
image except for the bad pixels.  2 is the default.

*** Error checking

Neither script is particularly robust in terms of flagging problems.
You should not expect particularly useful error messages if the
folders in the configuration file are not correct or if you give an
emission energy value that was not measured as an elastic image.  In
those cases, the program will almost certainly fail with some kind of
stack trace, but probably not with an immediately useful error
message.

** Mask

Along with each scan, a series of images are collected with the
incident beam at energies around the L alpha 1 line.  The XANES can be
extracted, then, as a function of emission energy by creating a mask
from the elastic energy which identifies the pixels on the camera that
are illuminated by photons of that energy.

For a given emission energy, the elastic image is read and processed
in three steps:

  1. Set the bad pixels (i.e. those with spuriously large values) to
     zero.  The "spuriously large value" is defined as larger than the
     bad pixel value from the configuration file.  Also remove all weak
     pixels, i.e. those with fewer than some cutoff, defined by the
     weak pixel value from the configuration file.

  2. lonely/social algorith,

     + Remove all "lonely" pixels.  These are the pixels that are
       illuminated but surrounded by fewer illuminated pixels than the
       lonely pixel value in the configuration file.

     + Add in all "social" pixels.  These are pixels which are dark, but
       are surrounded by enough illuminated pixels (i.e. more than the
       social pixel value from the configuration file) such that it, too,
       should be illuminated.

  3. areal meadin/mean algorithm

     + Set each pixel to the median or mean value of the pixels in a
       square centered at that pixel.

This results in a simple logical-AND mask for evaluating the signal at
each energy point from the Pilatus image.

When the ~-a~ flag is used with the ~herfd~ or ~rixs~ scripts, a 3- or
4-frame animated tiff file will be written which shows the steps from
elastic image to final mask.

** Scan conversion

At each energy point, the HERFD signal is computed from the Pilatus
image using the mask created by the algorithm described above.  The
counts on each pixel lying within the illuminated portion of the mask
are summed.  This sum is the HERFD signal at that incident energy.

A column data file is written containing the energy and several
scalars from the original measurement and a column containing the
HERFD signal.  This file can be imported directly into Athena.

** Working with Imager

Imager works out of the box on both linux and Windows, although the
way it handles 32-bit numbers with its inherent 24-bit sample depth is
somewhat confusing.

** Working with Image Magick

In principle [[http://www.imagemagick.org/script/index.php][Image Magick]] can be u sed instead of Imager, but doing so
is a bit of work.

I am using [[http://www.imagemagick.org/script/index.php][Image Magick]] and its [[http://www.imagemagick.org/script/perl-magick.php][Perl interface]] as one of the image
handling backends for this project.  As delivered, Image Magick cannot
handle the TIFF files as written by the [[http://www.dectris.com/sites/pilatus100k.html][Pilatus 100K]] imagine detector.
In order to be able to use Image Magick, it must be recompiled with a
larger bit depth.  This is done by re-compiling from source code.

You must have [[http://www.libtiff.org/][libtiff]] and its development libraries installed so that
Image Magick gets compiled with support for tiff files.  On Ubunutu,
it is called ~libtiff4-dev~.

Grab the trunk of the Image Magick development version

:       svn co https://www.imagemagick.org/subversion/ImageMagick/trunk ImageMagick

then

:      ./configure --with-quantum-depth=32

Presumably, the same could be done with any Image Magick source
tarball.

I also rebuilt the perl wrapper which comes with the Image Magick
source code in the ~PerlMagick~ folder.  This also was a bit tricky.
My Ubuntu system has perl 5.10.1 and therefore has a
~libperl.5.10.1.so~.  It did not, however, have a ~libperl.so~
symlinked to it.  To get the perl wrapper to build, I had to do

:      sudo ln -s /usr/lib/libperl.so.5.10.1 /usr/lib/libperl.so

Adjust the version number on the perl library as needed for your
computer.

I was unable to compile Image Magick for Windows using MinGW, even
armed with a fairly complete set of GnuWin32 libraries and even
attempting it with a stable version (as opposed to the development
trunk).  Oh well....
