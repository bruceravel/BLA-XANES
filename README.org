* Convert bent-laue analyzer images to XANES data

** Synopsis

A measurement set consists of

 + A column data file with columns of energy and scalars from the
   measurement.

 + One Pilatus image for each energy point containing the HERFD signal
   at that point.

 + A set of Pilatus images taken at energies around the fluorescence
   energy.  These are used to make a mask which identifies which
   pixels contain signal related to specific emission energies.

This software uses perl, [[https://metacpan.org/module/Imager][Imager]], and [[http://pdl.perl.org][PDL]] to process the images into a
high resolution XANES spectrum.  Imager is used to import data from
the signed 32 bit numbers.  That data is immediately pushed into a PDL
object for further processing.

** Installation

To install, do the following:

:      perl Build.PL
:      sudo ./Build installdeps  ## (if any dependencies are not met)
:      ./Build
:      ./Build test
:      sudo ./Build install


** Usage

There is a single programs installed from the bin/ folder.  ~bla~ is a
wrapper script around the five bent Laue tasks:

 1. ~herfd~: make a single HERFD spectrum at a specific
    emission energy

 2. ~rixs~: generate a sequence of HERFD spectra at a
    sequence of emission energies

 3. ~map~: convert a series of elastic images to an
    energy vs. pixel map

 4. ~mask~: compute the mask file for a secific emission energy

 5. ~point~: convert a specified BLA image to its HERFD value for a
    specified emission energy

*** The bla script

:  bla herfd [cxeasvnqh] <stub>
:  bla rixs  [cxasvnqh]  <stub>
:  bla map   [crvnqh]    <stub>
:  bla mask  [casvnqh]   <stub>
:  bla point [ceph]      <stub>
: 
:     --config  | -c    [string]  configuration file (required)
:     --energy  | -e    [integer] emission energy (required for herfd/point tasks)
:     --point   | -p    [integer] data point at which compute HERFD (required for point task)
:     --xdiini  | -x    [string]  XDI configuration file
:     --reuse   | -r    [flag]    reuse mask files for energy map if in outfolder
:     --animate | -a    [flag]    save gif animation of mask creation
:     --save    | -s    [flag]    save gif with mask
:     --verbose | -v    [flag]    write progress messages
:     --nocolor | -n    [flag]    turn off color coding of screen output
:     --quiet   | -q    [flag]    suppress progress messages
:     --help    | -h    [flag]    write this message and exit

  
The ~bla~ script assumes that scan files and image files have
related names.  In this example, the scan file is called ~Aufoil1.001~
and the image files are called ~Aufoil1_NNNNN.tif~.  The ~NNNNN~ in
the image file name indicates the data point and is reflected in one
of the columns of the scan file.  If your data do not follow these
patterns, this script will fail.  File locations are specified in the
configuration file.

:  examples:  bla herfd -c=/path/to/config.ini -e=9713 -a Aufoil1
:             bla rixs -c=/path/to/config.ini -a Aufoil1
:             bla map -c=/path/to/config.ini Aufoil1
:             bla mask -c=/path/to/config.ini -e=9713 Aufoil1
:             bla point -c=/path/to/config.ini -e=9713 -p=10 Aufoil1


Here, "Aufoil1" is the stub, i.e. the basename of the scan and image
files, and the ~-c~, ~-e~, and ~-a~ command line options are
demonstrated.

Options that are not used by a function (for example ~-e~ for ~rixs~
or ~map~, ~-a~ for ~map~, or ~-p~ for any task other than ~point~)
will be silently ignored.

~-c~ is required for all functions.

Since the ~point~ task returns a number intended for use during data
acquisition, verbosity is turned off regardless of the command line
switches.  Use the ~-q~ flag if you want to suppress screen messages
during the ~mask~ task.  Saving is turned on for the ~mask~ task
regardless of the command line switches.

*** Output

 + The output of the ~herfd~ task is a data file containing the
   HERFD spectrum at the specified eminssion energy and, if requested,
   gif images with the mask and the mask creation animation.

 + The output of the ~rixs~ task is the same as for the ~herfd~
   script at each emission energy.

 + The output of the ~map~ task is a datafile in a [[http://gnuplot.info/docs_4.2/gnuplot.html#x1-33600045.1.2][simple format]]
   which can be read by gnuplot and a gnuplot script for displaying
   the data.  The resulting image will plot a map of detector column
   vs detector row with the color axis showing energy.  Gif files for
   the masks at each emission energy are also written.

 + The output of the ~mask~ task is a single gif file containing the
   mask for the specified emission energy.

 + The output of the ~point~ task is the HERFD value extracted from a
   specified BLA image for a specified emission energy.  The value is
   printed to STDOUT.  If files containing the BLA image or the
   emission mask do not exist, 0 is printed to STDOUT.

The ~herfd~, ~rixs~, and ~map~ tasks are intended for post-processing
of a full data set.

The ~mask~ and ~point~ tasks are intended for inlining in the data
acquisition process.  The ~mask~ task should be run after measuring
the elastic images at the emission energy and before measuring the
HERFD data.  The ~mask~ task takes about 10 seconds.

The ~point~ task is intended for generating the HERFD value at a
specific emission energy during the scan.  This value can be used for
plotting or storing to the output data file.  The ~point~ task takes
lass than 1 second.

*** The configuration file

The configuration file is in the Windows-style ini format.  Here is an
example.

:   [measure]
:   emission   = 9703 9705 9707 9709 9711 9713 9715 9717 9719
:   scanfolder = /home/bruce/Data/NIST/10ID/2011.12/scans
:   tiffolder  = /home/bruce/Data/NIST/10ID/2011.12/tiffs
:   outfolder  = /home/bruce/Data/NIST/10ID/2011.12/processed
:   element    = Au
:   line       = La1
:
:   [steps]
:   steps = <<END
:   bad 400 weak 0
:   multiply by 5
:   areal mean radius 2
:   bad 400 weak 2
:   lonely 3
:   social 2
:   END

This configuration file can sit anywhere on disk and *must* be
specified at the command line when using the ~bla~ script.  I would
recommend that you put it in the current work directory wherever you
are working on your data.  You may wish to keep multiple configuration
files around for different experiments, different edges, etc.

In the ~[measure]~ section, the ~emission~ item, which is not used by
the ~herfd~ function, contains the list of emission energies at which
to generate HERFD spectra.  The next three items are the locations of
the scan files, the image files, and the output files.  The last two
items are used to properly scale the color palette of the energy map
by positively identifying the emission line measured.

The ~[steps]~ section is used to define the sequence of operations
used to make the mask at any emission energy.  The syntax of this
section is somewhat fussy.  It is essential that there are no spaces
after either instance of the word ~END~.  Other than that, whitespace
is not important, but spelling is.

The possible steps to mask creation are:

 1. Bad and weak pixel removal.  The syntax is ~bad # weak #~.  The
    first number indicates the value above which a pixel is assumed to
    be a bad pixel.  The second number is the value below which a
    pixel is considered weak.  Both bad and weak pixels are removed
    from the mask.

 2. Multiply emission image by an overall constant.  The syntax is
    ~multiply by #~ where the number is the constant scaling factor.

 3. Apply an areal median or mean to each pixel.  The syntax is 
    ~areal <median|mean> radius #~.  The number defines the size of
    the square considered around each pixel.  A value of 1 means a 3x3
    square, a valueof 2 means a 5x5 square.  The value of each pixel
    is set to either the mean or the median value of the pixels in the
    square.

 4. Remove all the lonely pixels.  A lonely pixel is one which is
    illuminated but is not surrounded by enough illuminated pixels.
    The syntax is ~lonely #~.  The number defines how many illuminated
    pixels are required for a pixel not to be considered lonely.

 5. Include all social pixels.  A social pixel is one which is not
    illuminated but is surrounded by enough illuminated pixels.  The
    syntax is ~social #~.  The number defines how many of the
    surrounding pixles must be illuminated for the pixel to be turned
    on.

The steps can come in any order and can be repeated.  At the end of
the final step, the illuminated pixels in the mask will be set to a
value of 1 so that the final mask can be used as an AND mask to create
the HERFD spectra..


*** Error checking

The script is not particularly robust in terms of flagging problems.
You should not expect particularly useful error messages if the
folders in the configuration file are not correct or if you give an
emission energy value that was not measured as an elastic image.  In
those cases, the program will almost certainly fail with some kind of
stack trace, but probably not with an immediately useful error
message.

*** XDI Output

When a configuration file containing XDI metadata is used, the output
files will be written in XDI format.  This is particularly handy for
the RIXS function.  If XDI metadata is provided, then the
~BLA.pixel_ratio~ metadatum will be written to the output file.  This
number is computed from the number of pixels illuminated in the mask
at each emission energy.  The pixel ratio for an emission energy is
the number of pixels from the emission energy with the largest number
of illuminated pixles divided by the number of illuminated pixels at
that energy.

The pixel ratio can be used to normalize the mu(E) data from each
emission energy.  The concept is that the normalized mu(E) data are an
approximation of what they would be if each emission energy was
equally represented on the face of the detector.

The version of Athena based on Demeter will be able to use these
values as importance or plot multiplier values if the ~Xray::XDI~
module is available.

** Mask

Along with each scan, a series of images are collected with the
incident beam at energies around the L alpha 1 line.  The XANES can be
extracted, then, as a function of emission energy by creating a mask
from the elastic energy which identifies the pixels on the camera that
are illuminated by photons of that energy.

For a given emission energy, the elastic image is read and processed
in three steps:

  1. Set the bad pixels (i.e. those with spuriously large values) to
     zero.  The "spuriously large value" is defined as larger than the
     bad pixel value from the configuration file.  Also remove all weak
     pixels, i.e. those with fewer than some cutoff, defined by the
     weak pixel value from the configuration file.

  2. lonely/social algorithm

     + Remove all "lonely" pixels.  These are the pixels that are
       illuminated but surrounded by fewer illuminated pixels than the
       lonely pixel value in the configuration file.

     + Add in all "social" pixels.  These are pixels which are dark, but
       are surrounded by enough illuminated pixels (i.e. more than the
       social pixel value from the configuration file) such that it, too,
       should be illuminated.

  3. areal meadin/mean algorithm

     + Set each pixel to the median or mean value of the pixels in a
       square centered at that pixel.

This results in a simple logical-AND mask for evaluating the signal at
each energy point from the Pilatus image.

When the ~-a~ flag is used with the ~herfd~ or ~rixs~ scripts, an animated
gif file will be written.  For ~herfd~, it shows the steps from
elastic image to final mask.  For ~map~, it shows the motion of the map across
the face of the detector.

** Scan conversion

At each energy point, the HERFD signal is computed from the Pilatus
image using the mask created as described above.  The
counts on each pixel lying within the illuminated portion of the mask
are summed.  This sum is the HERFD signal at that incident energy.

A column data file is written containing the energy and several
scalars from the original measurement and a column containing the
HERFD signal.  This file can be imported directly into Athena.

** Working with Imager

Imager works out of the box on both linux and Windows, although the
way it handles 32-bit numbers with its inherent 24-bit sample depth is
somewhat confusing.

** Working with Image Magick

In principle [[http://www.imagemagick.org/script/index.php][Image Magick]] can be u sed instead of Imager, but doing so
is a bit of work.

I am using [[http://www.imagemagick.org/script/index.php][Image Magick]] and its [[http://www.imagemagick.org/script/perl-magick.php][Perl interface]] as one of the image
handling backends for this project.  As delivered, Image Magick cannot
handle the TIFF files as written by the [[http://www.dectris.com/sites/pilatus100k.html][Pilatus 100K]] imagine detector.
In order to be able to use Image Magick, it must be recompiled with a
larger bit depth.  This is done by re-compiling from source code.

You must have [[http://www.libtiff.org/][libtiff]] and its development libraries installed so that
Image Magick gets compiled with support for tiff files.  On Ubunutu,
it is called ~libtiff4-dev~.

Grab the trunk of the Image Magick development version

:       svn co https://www.imagemagick.org/subversion/ImageMagick/trunk ImageMagick

then

:      ./configure --with-quantum-depth=32

Presumably, the same could be done with any Image Magick source
tarball.

I also rebuilt the perl wrapper which comes with the Image Magick
source code in the ~PerlMagick~ folder.  This also was a bit tricky.
My Ubuntu system has perl 5.10.1 and therefore has a
~libperl.5.10.1.so~.  It did not, however, have a ~libperl.so~
symlinked to it.  To get the perl wrapper to build, I had to do

:      sudo ln -s /usr/lib/libperl.so.5.10.1 /usr/lib/libperl.so

Adjust the version number on the perl library as needed for your
computer.

I was unable to compile Image Magick for Windows using MinGW, even
armed with a fairly complete set of GnuWin32 libraries and even
attempting it with a stable version (as opposed to the development
trunk).  Oh well....
