#!/usr/bin/perl

use strict;
use warnings;
use Xray::BLA;
use Config::IniFiles;
use Getopt::Long;
use Pod::Usage;

my $verbose    = 1;
my $nocolor    = 0;
my $reuse      = 0;
my $configfile = q{};
my $result  = GetOptions ('verbose|v'   => \$verbose,
			  'reuse|r'     => \$reuse,
			  'config|c=s'  => \$configfile,
			  'nocolor|n'   => \$nocolor,
			  'quiet|q'     => sub { $verbose = 0 },
			  'help|h'      => sub{ pod2usage(1); exit 0},
			 );

pod2usage(1) && exit 1 if not $ARGV[0];
pod2usage(1) && exit 1 if not $configfile;

tie my %ini, 'Config::IniFiles', ( -file => $configfile );

my $spectrum = Xray::BLA->new();
$spectrum -> scanfolder	($ini{measure}{scanfolder});
$spectrum -> tifffolder	($ini{measure}{tiffolder});
$spectrum -> outfolder	($ini{measure}{outfolder});
$spectrum -> stub       ($ARGV[0]);
$spectrum -> colored(0) if $nocolor;

$spectrum -> bad_pixel_value   ($ini{pixel}{bad})      if exists $ini{pixel}{bad};
$spectrum -> weak_pixel_value  ($ini{pixel}{weak})     if exists $ini{pixel}{weak};
$spectrum -> lonely_pixel_value($ini{pixel}{lonely})   if exists $ini{pixel}{lonely};
$spectrum -> social_pixel_value($ini{pixel}{social})   if exists $ini{pixel}{social};
$spectrum -> maskmode          ($ini{pixel}{maskmode}) if exists $ini{pixel}{maskmode};
$spectrum -> radius            ($ini{pixel}{radius})   if exists $ini{pixel}{radius};

my @elastic = split(" ", $ini{measure}{emission});
my $need_to_check = 0;
foreach my $e (@elastic) {
  $spectrum -> energy($e);
  my $file = $spectrum->mask_file("3", 'tif');
  $file = $spectrum->mask_file("2", 'tif') if not -e $file;
  if (not -e $file) {
    $spectrum -> mask(save=>1, verbose=>$verbose, animate=>0)
  } elsif (not $reuse) {
    $spectrum -> mask(save=>1, verbose=>$verbose, animate=>0)
  } else {
    $need_to_check = 1;
  };
  $spectrum -> push_elastic_file_list($file);
};
$spectrum->check, $spectrum -> import_elastic_image if $need_to_check;
my @images = map {$spectrum->read_image($_)} @{$spectrum->elastic_file_list};
$spectrum->elastic_image_list(\@images);
$spectrum->elastic_energies(\@elastic);

$spectrum -> energy_map(verbose => $verbose);

exit 0;


=head1 NAME

map - convert a sequence of BLA elastic images to an energy map

=head1 SYNOPSIS

map [options] <stub>

 Options:
     --config  | -c   [string]  configuration file (required)
     --reuse   | -r   [flag]    reuse mask files if found in outfolder
     --verbose | -v   [flag]    write progress messages
     --nocolor | -n   [flag]    turn off color coding of screen output
     --quiet   | -q   [flag]    suppress progress messages
     --help    | -h   [flag]    write this message and exit

=head1 Options

=over 8

=item B<--config>, B<-c>  (Required)

Specify the location of the ini-style config file giving the input and
output locations on disk and other information.

=item B<--reuse>, B<-r>

Reuse mask files if found in output folder.

=item B<--verbose>, B<-v>   (Default)

Write progress messages to STDOUT.

=item B<--nocolor>, B<-n>

Turn off color coding of screen output

=item B<--quiet>, B<-q>

Suppress progress messages to STDOUT.

=item B<--help>, B<-h>

Print this help message and exit.

=back

=head1 DESCRIPTION

A measurement set consists of

=over 4

=item *

A column data file with columns of energy and scalars from the
measurement.

=item *

One Pilatus image for each energy point containing the HERFD signal at
that point.

=item *

A set of Pilatus images taken at energies around the fluorescence
energy.  These are used to make a mask which identifies which pixels
contain signal related to specific emission energies.

=back

This software uses perl and Image Magick to process the images into a
high resolution XANES spectrum.

=cut

