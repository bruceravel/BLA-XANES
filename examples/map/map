#!/usr/bin/perl

use strict;
use warnings;
use Imager;
use Config::IniFiles;
use Getopt::Long;
use Pod::Usage;
use File::Spec;
use Data::Dump qw(dump);
use Term::Sk;
use Ifeffit;

my $maskfolder = '/home/bruce/Data/NIST/10ID/2011.12/processed/masks';

tie my %ini, 'Config::IniFiles', ( -file => '/home/bruce/git/BLA-XANES/share/config.ini' );

my @elastic = split(" ", $ini{measure}{emission});
my @images = map {Imager->new(file=>$_)} map {File::Spec->catfile($maskfolder, 'Aufoil1_'.$_.'_mask_2.tif')} @elastic;


my ($ncols, $nrows) = (487, 195);
open(my $M, '>', 'map.dat');
my $counter = Term::Sk->new('Making map, time elapsed: %8t %15b (row %c of %m)',
			    {freq => 's', base => 0, target=>$nrows});

foreach my $r (0 .. $nrows-1) {
  $counter->up;

  my @all = ();
  foreach my $ie (0 .. $#elastic) {
    my @colors = $images[$ie]->getscanline(y=>$r, type=>'float');
    my @y = map { my @rgba = $_->rgba; $rgba[0]*2**32 } @colors;

    ## turn off a pixel that is illuminated and has dark pixels to the left and right
    my @z = ();
    foreach my $i (1 .. $#y-1) {
      push(@z, $i) if (($y[$i-1] == 0) and ($y[$i+1] == 0));
    };
    foreach my $j (@z) {
      $y[$j] = 0;
    };
    ## turn on a pixel that is dark and has illuminated pixels to the left and right
    @z = ();
    foreach my $i (1 .. $#y-1) {
      push(@z, $i) if ((int($y[$i-1]) == 10) and (int($y[$i+1]) == +10));
    };
    foreach my $j (@z) {
      $y[$j] = 10;
    };
    push @all, \@y;
  };


  my @linemap = map {0} (0 .. $ncols-1);
  my @represented = map {[0]} (0 .. $ncols-1);

  my (@x, @y);

  my $stripe = 0;
  foreach my $list (@all) {
    my $on = 0;
    my $first = $list->[0];
    $on = 1 if $first > 0;
    foreach my $p (0 .. $#{$list}) {
      if ($list->[$p] > 0) {
	push @{$represented[$p]}, $elastic[$stripe];
	$first = $p if ($on == 0);
	$on = 1;
      } else {
	if ($on) {
	  #print join("   ", $elastic[$stripe], $first, $p, int(($p+$first)/2)), $/;
	  $linemap[ int(($p+$first)/2) ] = $elastic[$stripe];
	  push @x, int(($p+$first)/2);
	  push @y, $elastic[$stripe];
	};
	$on = 0;
      };
    };
    if ($on) {
      #print join("   ", $elastic[$stripe], $first, $#{$list}, int(($#{$list}+$first)/2)), $/;
      $linemap[ int(($#{$list}+$first)/2) ] = $elastic[$stripe];
      push @x, int(($#{$list}+$first)/2);
      push @y, $elastic[$stripe];
    };
    ++$stripe;
  };

  foreach my $i (0 .. $#represented) {
    my $n = sprintf("%.1f", $#{$represented[$i]});
    my $val = '(' . join('+', @{$represented[$i]}) . ')/' . $n;
    $linemap[$i] = eval "$val" || 0;
  };
  #print join("|", @linemap), $/;
  #exit;

  #  $linemap[0] = $elastic[0]-2 if ($linemap[0] == 0);
  foreach my $k (0 .. $#linemap) {
    next if $linemap[$k] > 0;
    $linemap[$k] = $elastic[0]-2;
  };
  my $flag = 0;
  foreach my $k (0 .. $#linemap) {
    $flag = 1 if $linemap[$k] > $elastic[0];
    next if $linemap[$k] >= $elastic[0];
    $linemap[$k] = $elastic[$#elastic]+2 if $flag;
  };


  # my $first = 0;
  # foreach my $i (1..$#linemap) {
  #   next if $linemap[$i] == 0;
  #   foreach my $j ($first+1 .. $i-1) {
  #     my $ediff = $linemap[$i] - $linemap[$first];
  #     $linemap[$j] = $linemap[$first] + $ediff * ($j - $first) / ($i - $first);
  #   };
  #   $first = $i;
  # };



  my @zz = smooth(4, \@linemap);

  foreach my $i (0..$#zz) {
    print $M "  $r  $i  $zz[$i]\n"
  };
  print $M $/;
#  print dump(@represented);

};
$counter->close;


close $M;


## see ifeffit-1.2.11d/src/lib/decod.f, lines 453-461
sub smooth {
  my ($repeats, $rarr) = @_;
  my @array = @$rarr;
  my @smoothed = ();
  foreach my $x (1 .. $repeats) {
    $smoothed[0] = 3*$array[0]/4.0 + $array[1]/4.0;
    foreach my $i (1 .. $#array-1) {
      $smoothed[$i] = ($array[$i] + ($array[$i+1] + $array[$i-1])/2.0)/2.0;
    };
    $smoothed[$#array] = 3*$array[$#array]/4.0 + $array[$#array-1]/4.0;
    @array = @smoothed;
  };
  return @smoothed;
};
